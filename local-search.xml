<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络爬虫3</title>
    <link href="/2020/03/01/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB3/"/>
    <url>/2020/03/01/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB3/</url>
    
    <content type="html"><![CDATA[<h1 id="第三部分：数据解析"><a href="#第三部分：数据解析" class="headerlink" title="第三部分：数据解析"></a>第三部分：数据解析</h1><p>数据解析的功能是从网页信息或者下载到本地的信息中，提取出想要的信息。知识结构如下：<br><img src="/images/spider12.png" srcset="/img/loading.gif" alt="" title="spider"> </p><h2 id="Part-1-xpath与lxml"><a href="#Part-1-xpath与lxml" class="headerlink" title="Part 1: xpath与lxml"></a>Part 1: xpath与lxml</h2><p>xpat</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络爬虫2</title>
    <link href="/2020/02/25/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB2/"/>
    <url>/2020/02/25/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB2/</url>
    
    <content type="html"><![CDATA[<h1 id="第二部分：网络请求"><a href="#第二部分：网络请求" class="headerlink" title="第二部分：网络请求"></a>第二部分：网络请求</h1><p>本部分主要介绍如何通过url链接访问到目标服务器的过程。主要介绍两个库：urllib库和request库。知识结构如下：<br><img src="/images/spider7.png" srcset="/img/loading.gif" alt="" title="spider"> </p><h2 id="Part-1-urllib库"><a href="#Part-1-urllib库" class="headerlink" title="Part 1: urllib库"></a>Part 1: urllib库</h2><p>urllib库是python自带的库，功能比较基础，全面。在python3中，所有的urllib库的网络请求功能，都被集中到urllib.request模块下面了。   </p><p>1.1 urlopen函数<br>这个函数的作用是，通过url链接，访问服务器。<br>例1：通过urlopen()访问百度主页：      </p><pre><code>from urllib import requesturl = &#39;http://www.baidu.com&#39;resp = request.urlopen(url, timeout = 3)print(type(resp))print(resp.read())</code></pre><p>返回的结果如下：    </p><pre><code>&lt;class &#39;http.client.HTTPResponse&#39;&gt;b&#39;&lt;!DOCTYPE html&gt;\n&lt;!--STATUS OK--&gt;\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n</code></pre><p>可以看到，返回值的类型是http定义下的client下的HTTPResponse类；<br>需要对这个类进行仔细研究，其中的比较重要的属性和方法如下：<br>a. _method = ‘GET’  #说明访问的方法为前面介绍的8种中的get；<br>b. status = 200     #说明返回访问正常<br>c. url = ‘<a href="http://www.baidu.com&#39;#" target="_blank" rel="noopener">http://www.baidu.com&#39;#</a> 说明这个网页最后定位的地址是百度主页；<br>d. fp # 这个属性实际上是可以将这个网页写入本地的buffer，读取这个buffer的方式为’rb’<br>e. headers  # 这个是服务器给网页申请发回的头文件，其子属性headers中存在着一些有用的信息，如：Content-Encoding, Date, Server等内容；</p><p>其次是对.read()内容的说明。这里输出的格式是一行（Pycharm），而且也没有出现类似于“百度一下，你就知道”这样的logo，这是因为编码的方式不对。这里将编码模式修改为：utf-8，即可获取下面的结果：    </p><pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;                    &lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;    &lt;meta content=&quot;always&quot; name=&quot;referrer&quot;&gt;    &lt;meta name=&quot;theme-color&quot; content=&quot;#2932e1&quot;&gt;    &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;    &lt;link rel=&quot;search&quot; type=&quot;application/opensearchdescription+xml&quot; href=&quot;/content-search.xml&quot; title=&quot;百度搜索&quot; /&gt;    &lt;link rel=&quot;icon&quot; sizes=&quot;any&quot; mask href=&quot;//www.baidu.com/img/baidu_85beaf5496f291521eb75ba38eacbd87.svg&quot;&gt;    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//s1.bdstatic.com&quot;/&gt;    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t1.baidu.com&quot;/&gt;    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t2.baidu.com&quot;/&gt;    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t3.baidu.com&quot;/&gt;    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t10.baidu.com&quot;/&gt;    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t11.baidu.com&quot;/&gt;    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//t12.baidu.com&quot;/&gt;    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//b1.bdstatic.com&quot;/&gt;    &lt;title&gt;百度一下，你就知道&lt;/title&gt;    ...</code></pre><p>为了省略，就只显示部分内容，并将空白删除。可以看到，这里的结果已经能够显示我们获取了百度网页的内容。<br>具体地代码修改为：<code>print(resp.read().decode(&#39;utf-8&#39;))</code>;    </p><p>1.2 urlretrieve函数<br>这个函数的作用是，能够将网页上的内容保存下来。<br>例2：利用urlretrieve函数将百度主页下载下来：    </p><pre><code>from urllib import requestrequest.urlretrieve(&#39;http://www.baidu.com/&#39;,&#39;baidu.html&#39;)</code></pre><p>运行之后，可以看到本地的路径下多了一个baidu.html文件，这个文件就是复制的百度主页的文件。<br>这里首先对urlretrieve这个函数进行解析：<br>urlretrieve(url, filename=None, reporthook=None, data=None)<br>参数url：下载链接地址<br>参数filename：指定了保存本地路径（如果参数未指定，urllib会生成一个临时文件保存数据。）<br>参数reporthook：是一个回调函数，当连接上服务器、以及相应的数据块传输完毕时会触发该回调，我们可以利用这个回调函数来显示当前的下载进度。<br>参数data：指post导服务器的数据，该方法返回一个包含两个元素的(filename, headers) 元组，filename 表示保存到本地的路径，header表示服务器的响应头。   </p><p>urlretrieve还能够提示下载进度；<br>例3：利用urlretrieve函数将百度主页下载下来，并显示下载的进度：    </p><pre><code>from urllib import requestdef cbk(down, block, size):    &#39;&#39;&#39;回调函数    down:已经下载的数据块    block:数据块的大小    size:远程文件的大小    &#39;&#39;&#39;    per = 100.0 * down * block / size    if per &gt; 100:        per = 100    print(&#39;%.2f%%&#39; % per)url = &#39;http://www.baidu.com&#39;request.urlretrieve(url,reporthook = cbk)</code></pre><p>此时，就可以显示下载进度了。     </p><p>1.3 urlencode和parse_qs函数<br>发送浏览器请求时，如果有中文或者特殊字符，浏览器会自动给这些字符进行编码。</p><blockquote><p>备注：这里用到的两个函数是在parse类中。<br>例4：在百度中搜索“爬虫”，打开Chrome浏览器的检查，翻到Network页面，就会发现此时跳转链接如下截图：<br><img src="/images/spider8.PNG" srcset="/img/loading.gif" alt="" title="百度搜索爬虫的跳转链接">    </p></blockquote><p>那么，为什么是上面那个链接呢？是因为浏览器将输入的爬虫进行了编码。这里使用的编码方式可以通过urlencode进行模拟。<br>例4：用urlencode模拟浏览器搜索爬虫的时候的字符：    </p><pre><code>from urllib import parsekw = {&#39;wd&#39;:&#39;爬虫&#39;}res = parse.urlencode(kw)    print(res)</code></pre><p>这里的输出结果就是“wd=%E7%88%AC%E8%99%AB”了，与浏览器的一致；<br>至于为什么有wd=，就要看百度这个界面的搜索模式了。百度的搜索方法是：<br>在www.baidu.com/s?ite = utf-8&amp;wd=关键字<br>例5：通过编程的方式，返回百度搜索“爬虫”的界面：     </p><pre><code>from urllib import request, parsekw = {&#39;wd&#39;:&#39;爬虫&#39;}url = &#39;http://www.baidu.com/s?&#39;url_get = url + &#39;e=UTF-8&amp;&#39; + parse.urlencode(kw)   request.urlretrieve(url_get,&#39;spider.html&#39;)</code></pre><p>此时即可观察到返回的html网页。<br>如果想把输出的编码的字符转换为汉字或者能够读懂的字体的话，需要做编码格式的转换，这里就用到了parse_qs函数。<br>例6：将爬虫的编码形式恢复到汉字形式：    </p><pre><code>from urllib import parse    wd = &#39;wd=%E7%88%AC%E8%99%AB&#39;res = parse.parse_qs(wd)print(type(res))print(res)</code></pre><p>输出的结果为：<code>&lt;class &#39;dict&#39;&gt;</code>和<code>{&#39;wd&#39;: [&#39;爬虫&#39;]}</code>，可以看到，输出的结果是字典的形式，而且输入的字典中value的值得形式是str，现在变成了list。    </p><p>1.4 urlparse和urlsplit函数<br>这两个函数的作用是，对url的信息进行分割。    </p><blockquote><p>备注：这里的两个函数属于parse库。<br>例7：分别利用urlparse和urlsplit函数对例5的url_get进行分割：   </p><pre><code>from urllib import parseurl_get = &#39;https://www.baidu.com/s?ie=UTF-8&amp;wd=%E7%88%AC%E8%99%AB&#39;res_parse = parse.urlparse(url_get)    res_split = parse.urlsplit(url_get)    print(res_parse)print(res_split)</code></pre><p>输出的结果为：</p><pre><code>ParseResult(scheme=&#39;https&#39;, netloc=&#39;www.baidu.com&#39;, path=&#39;/s&#39;, params=&#39;&#39;, query=&#39;ie=UTF-8&amp;wd=%E7%88%AC%E8%99%AB&#39;, fragment=&#39;&#39;)SplitResult(scheme=&#39;https&#39;, netloc=&#39;www.baidu.com&#39;, path=&#39;/s&#39;, query=&#39;ie=UTF-8&amp;wd=%E7%88%AC%E8%99%AB&#39;, fragment=&#39;&#39;)</code></pre><p>可以看到，这两个函数都对这个url进行了拆分,对比上一节的内容，可以看出拆分的结果。需要说明的是，这两个函数的区别在于，parse还会对params进行拆分。    </p></blockquote><p>1.5 实例1： 爬取京东的主页并下载     </p><pre><code>from urllib import parse, requestdef main(url):    res = request.urlopen(url)    print(res.status)    print(res.read().decode(&#39;utf-8&#39;))    request.urlretrieve(url, &#39;jd.txt&#39;)if __name__ == &#39;__main__&#39;:    url = &#39;https://www.jd.com/&#39;    main(url)</code></pre><p>可以在文件中查看下载的资源。这里其实1个例子足够了。</p><h2 id="Part-2-requests库"><a href="#Part-2-requests库" class="headerlink" title="Part 2: requests库"></a>Part 2: requests库</h2><p>这个库是需要自己下载安装的，直接pip install requests就可以了。   </p><p>2.1 首先介绍requests库的7个方法：<br><img src="/images/spider9.PNG" srcset="/img/loading.gif" alt="" title="requests库的7种方法"><br>其实，这些方法也可以作为request方法的请求方式，如下：<br><img src="/images/spider10.PNG" srcset="/img/loading.gif" alt="" title="requests库的请求方式"><br>这里的**kwargs常用的13个参数如下：<br>a. params:字典或字节序列，作为参数增加到URL中;<br>b. data:字典、字节序列或文件对象，作为request的内容，但是并不放到URL链接里，放在URL链接对应位置作为数据存储；当然也可以把一个字符串赋值给data，该字符串放在URL所对应的位置;<br>c. json::JSON数据，作为request的内容提交，放在服务器的json里面;<br>d. headers:字典，HTTP定制头;<br>e. cookies:字典或CookieJar,request中的cookie;<br>f. auth:元组，支持HTTP认证功能;<br>g. files:字典类型，向某个链接提交传输文件;<br>h. timeout:设定超时时间，单位为s.如果规定时间内服务器不能返回就会产生一个timeout异常;<br>j. proxis:字典类型，设定访问代理服务器，可以增加登录认证，如增加登录用户名和密码。主要用于隐藏爬取网页的源网站，防止爬虫的逆追踪;<br>k. allow_redirects:True/False,默认为True，重定向开关;<br>l. steam:True/False,默认为True，获取内容后立即下载;<br>m. verify:True/False,默认为True，认账SSL证书开关;<br>n. cert:本地SSL证书路径</p><p>例8：抓取百度主页：   </p><pre><code>import requestsurl = &#39;http://www.baidu.com&#39;res = requests.get(url)print(type(res))print(res.status_code)print(res.text)</code></pre><p>这里可以返回百度主页的信息。需要关注的是res所属的类别<code>&lt;class &#39;requests.models.Response&#39;&gt;</code>。这个类中需要我们关注如下的5种属性：<br><img src="/images/spider11.PNG" srcset="/img/loading.gif" alt="" title="Response类的5种属性"><br>借助于上述属性，对例8的代码进行优化，如下：    </p><pre><code>import requestsdef getHtml(url):    try:        res = requests.get(url, timeout = 3)        res.raise_for_status()        res.encoding = res.apparent_encoding        return res.text    except:        return &#39;产生异常&#39;if __name__ == &#39;__main__&#39;:    url = &#39;http://www.baidu.com&#39;    res = getHtml(url)    print(res)</code></pre><p>其中，timeout是访问超时设置，raise_for_status是说返回码如果不对的话，就发出警报；res.encoding = res.apparent_encoding是用来改变text的输出的码制。    </p><p>实例2：爬取亚马逊主页<br>按照例8中展示的方法，当我们爬取亚马逊的主页的时候，出现了异常，代码为503，这个代码表示服务器拒绝访问这个页面。<br>这是因为我们发出的请求头不对。我们在代码中加入：<code>print(res.request.headers)</code>可以看到此时的请求头为：    </p><pre><code>{&#39;User-Agent&#39;: &#39;python-requests/2.22.0&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;}</code></pre><p>其中，可以看到我们访问的爬虫的头部信息为python的requests类，并不是浏览器。因而亚马逊为了反爬虫，对我们的访问提出了拒绝。改进方案：     </p><pre><code>import requestsdef getHtml(url):    try:        kv = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36&#39;}        res = requests.get(url, timeout=3, headers = kv)        print(res.request.headers)        res.raise_for_status()        res.encoding = res.apparent_encoding        return res.text    except:        return &#39;产生异常&#39;if __name__ == &#39;__main__&#39;:    url = &#39;https://www.amazon.cn/&#39;    res = getHtml(url)    print(res)</code></pre><p>这里可以看到，我们将输出的请求的头部伪装成为一个正常的浏览器，亚马逊就响应我们的请求了。其中，kv是头部信息，主要修改了User-Agent。里面的字典内的值是取自于Chorme的检查。<br>那么，如何利用request库将文件保存在本地呢？这里利用如下格式：     </p><pre><code>with open(path, &#39;wb&#39;) as f:    f.write(res.content)</code></pre><p>例9：保存迈克尔杰克逊的一张图片：    </p><pre><code>import requestsdef getHtml(url, path):    try:        kv = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36&#39;}        res = requests.get(url, timeout=3, headers = kv)        with open(path, &#39;wb&#39;) as f:            f.write(res.content)    except:        return &#39;产生异常&#39;if __name__ == &#39;__main__&#39;:    path = &#39;D:/Pycharm/spider/MJ.jpg&#39;    url = &#39;https://dss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1135862589,761779521&amp;fm=179&amp;app=42&amp;f=JPEG?w=121&amp;h=140&#39;    res = getHtml(url, path)    print(res)</code></pre><p>这里就可以看到文档下保存的MJ的图片了。</p><blockquote><p>备注：注意urlretrieve和requests的文件保存方式的区别。    </p></blockquote><h2 id="Part-3-补充问题"><a href="#Part-3-补充问题" class="headerlink" title="Part 3:补充问题"></a>Part 3:补充问题</h2><p>补充问题1：如何将申请伪装成为浏览器发送的？<br>如果使用urllib库，那么需要如下操作：</p><pre><code>from urllib import requesturl = &#39;http://www.baidu.com&#39;kv = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36&#39;}req = request.Request(url, headers = kv)resp = request.urlopen(req)print(resp.read().decode(&#39;utf-8&#39;))</code></pre><p>需要说明的是，这里利用了Request这个类，将浏览器的信息塞给这个类的实例化中的headers部分。<br>如果使用requests库，已经在实例2中展示过了。        </p><p>补充问题2：如何设置访问的IP地址？<br>由于爬虫需要快速访问服务器多次，而有的服务器就会对相同IP地址的访问次数进行限制。为了反反爬虫，这里通过设置代理IP的形式进行对抗。<br>常见的IP代理网址：<br>a. 西刺免费代理：<a href="http://www.xicidaili.com" target="_blank" rel="noopener">http://www.xicidaili.com</a><br>b. 快代理：<a href="http://www.kuaidaili.com" target="_blank" rel="noopener">http://www.kuaidaili.com</a><br>c. 代理云：<a href="http://www.dailiyun.com" target="_blank" rel="noopener">http://www.dailiyun.com</a>     </p><blockquote><p>备注：免费代理使用的人较多，可能会产生各种问题。<br>类型1：使用urllib库：    </p><pre><code>from urllib import request  url = &#39;http://httpbin.org/ip&#39;  handler = request.ProxyHanlder(&#39;http&#39;:&#39;218.66.161.88:31769&#39;}opener = request.build_opener(handler)    req = request.Request(url)resp = opener.open(req)    print(resp.read())</code></pre><p>这里是有错误的，报值一直如下：    </p><pre><code>urllib.error.URLError: &lt;urlopen error [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。&gt;</code></pre><p>之后学到改进方案，再回这里整改。    </p></blockquote><p>补充问题3：如何给访问申请增加cookie？<br>之前介绍过,cookie是用来给服务器提供身份验证的东西。<br>cookie的参数如下：<br>a. name:cookie的名字；<br>b. value:cookie的值；<br>c. expirse:cookie的过期时间；<br>d. path：cookie作用的路径；<br>e. domain:cookie作用的域名；<br>f. secure:是否只有在http协议下起作用。<br>那么，如何利用呢？这里需要使用http.cookiejar库。那么首先介绍这个库。<br>CookieJar类有一些子类，分别是FileCookieJar，MozillaCookieJar，LWPCookieJar。<br>CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。<br>FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。<br>MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。<br>LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。<br>例10：访问百度主页，并获取主页返回的cookies:    </p><pre><code>import urllibfrom http.cookiejar import CookieJarurl = &#39;http://www.baidu.com/&#39;headers = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36&#39;}cookie = CookieJar()handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)resp = opener.open(url)print(cookie)</code></pre><p>输出的结果为：    </p><pre><code>&lt;CookieJar[&lt;Cookie BAIDUID=99909F7DF63F80ADD7D4FFF9E355E748:FG=1 for .baidu.com/&gt;, &lt;Cookie BIDUPSID=99909F7DF63F80ADA18B24053F86FD2D for .baidu.com/&gt;, &lt;Cookie H_PS_PSSID=1459_21107_30841_30823_26350_22157 for .baidu.com/&gt;, &lt;Cookie PSTM=1582962305 for .baidu.com/&gt;, &lt;Cookie delPer=0 for .baidu.com/&gt;, &lt;Cookie BDSVRTM=0 for www.baidu.com/&gt;, &lt;Cookie BD_HOME=0 for www.baidu.com/&gt;]&gt;</code></pre><p>这里输出的cookiejar的一个实例。其中的关键字是BAIDUID, BIDUPSID, H_PS_PSSID, PSTM, delPer, BDSVRTM以及BD_HOME。如果给过程添加debug，我们观察一下opener。opener中实际上已经包含了服务器返回给申请的cookie信息，链接为：opener-&gt;handlers-&gt;08-&gt;cookiejar-&gt;_cookies-&gt;’.baidu.com’-&gt;’/‘下面。<br>如果想利用返回的cookie继续访问百度的话，直接用opener即可。     </p><pre><code>import urllibfrom urllib import parsefrom http.cookiejar import CookieJarurl = &#39;http://www.baidu.com/&#39;headers = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36&#39;}cookie = CookieJar()handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)resp = opener.open(url)print(cookie)kw = {&#39;wd&#39;:&#39;爬虫&#39;}url = &#39;http://www.baidu.com/s?&#39;url_get = url + &#39;e=UTF-8&amp;&#39; + parse.urlencode(kw) resp = opener.open(url_get)print(cookie)</code></pre><p>那requests库怎么使用cookie？    </p><pre><code>import requestsurl = &#39;http://www.baidu.com&#39;headers = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36&#39;}session = requests.session()session.post(url, headers = headers)url_get = &#39;http://www.baidu.com/s?wd=Cokey&#39;resp = session.get(url_get)</code></pre><p>在requests库中，将所有的信息存在session中了。debug一下，观察session的类别，会发现cookies的位置如下：session-&gt;cookies-&gt;_cookies-&gt;’baidu.com’-&gt;’/‘。</p><p>这一块的内容总结到此。</p><blockquote><p>备注：requests库是依赖于python自带的urllib库的。这两个库的使用习惯来说，requests库更加好用，更加推荐。     </p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络爬虫1</title>
    <link href="/2020/02/25/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB1/"/>
    <url>/2020/02/25/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB1/</url>
    
    <content type="html"><![CDATA[<h1 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h1><p>这一部分的内容是，从网络上爬取数据。<br>本部分内容将分为5部分：网络爬虫的基础知识，网络请求，数据解析，数据存储与展示以及Scrapy。其中，最重要的是Scrapy，其满足了现在爬虫的要求。<br>整个部分的知识模块如下：<br><img src="/images/spider1.png" srcset="/img/loading.gif" alt="" title="spider"> </p><h1 id="第一部分：网络爬虫的基础知识"><a href="#第一部分：网络爬虫的基础知识" class="headerlink" title="第一部分：网络爬虫的基础知识"></a>第一部分：网络爬虫的基础知识</h1><p>本部分将由3板块构成，结构如下：<br><img src="/images/spider2.png" srcset="/img/loading.gif" alt="" title="basic knowledge"><br>这三部分分别是：网页的基本组成，http协议以及爬虫的相关概念。</p><h2 id="Part-1：网页的基本组成"><a href="#Part-1：网页的基本组成" class="headerlink" title="Part 1：网页的基本组成"></a>Part 1：网页的基本组成</h2><p>这部分将对网页的基础知识进行补充，以便于后续的网页数据的提取。   </p><p>1.1 网页的基本结构<br>首先给出一个网页的基本形式，如下图：<br><img src="/images/spider3.PNG" srcset="/img/loading.gif" alt="" title="example of html"><br>完整HTML包括html DOCTYPE声明、title标题、head、网页编码声明等内容。<br>a. html DOCTYPE声明<br>DOCTYPE是document type(文档类型)的简写，用来说明你用的XHTML或者HTML是什么版本，是标准化网页内容所需要的。所给示例的图片中，&lt;!DOCTYPE html&gt;就是html DOCTYPE声明。<br>b. head<br><code>&lt;head&gt;&lt;/head&gt;</code>标签用于标识HTML的头部区域，<head>和<meta name="generator" content="Hexo 4.2.0"></head>之间的内容都属于头部区域中的内容，主要包括一些网页相关的信息，如网页标题、字符集、网页描述等信息，还可以包括script代码等。示例中，head包含了meta, title等内容。<br>c. title<br>title显示的是网页打开之后，页标签的显示内容。例如：<br><img src="/images/spider4.jpg" srcset="/img/loading.gif" alt="" title="title of html"><br>d. meta<br><code>&lt;meta&gt;</code>标签用来定义文档的元数据，使用“名称=值”的形式。一般使用它来描述当前页面的特性。提供有关页面的元信息，页面编码、刷新跳转、描述、更新频度等内容。示例中，meta描述了name和content的两组实例。<br>e. body<br><code>&lt;body&gt;&lt;/body&gt;</code>是放置页面内容的地方，所有需要在浏览器窗口中显示的内容都需要放置在<body></body>标签对之间。<br>f. html<br><code>&lt;html&gt;&lt;/html&gt;</code>标签是HTML页面中所有标签的顶层标签，一个页面有且只有一对该标签，页面中的所有标签和内容都必须放在<html></html>标签对之间。</p><p>1.2 标签的标准格式<br>不同的加载内容，有不同的标准格式。<br>a. 注释<br>形式：<code>&lt;!--string--&gt;</code>其中，string是注释的内容；<br>b. Meta<br>例如，示例中的<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>表示使用的编码方式是utf-8.<br>meta的内容都是放在与<code>&lt;meta &gt;</code>中的。<br>c. body, html, head, title等<br>这些标签的形式都是<code>&lt;body&gt;</code>表示开始，<code>&lt;/body&gt;</code>表示结束。它们中间的部分就表示这个模块的内容。<br>d. div标签<br>div定义文档中的分区或节，采用的格式也是<code>&lt;div&gt; &lt;/div&gt;</code>。<br>e. a标签<br>a标签一般用于定义超链接，格式：<code>&lt;a&gt; &lt;/a&gt;</code><br>f. img标签<br>img标签一般用于表示所使用的的图片的连接，格式:<code>&lt;img src = &#39;  &#39;&gt;</code><br>g. table标签<br>table标签一般用于表示输入的表格，格式： <code>&lt;table&gt; &lt;/table&gt;</code>。一般情况下，table标签定义在表格外围，tr用于在表格内定义属性。    </p><p>1.3 树形结构<br>html文本是有格式的。以上面的例子来看， 最外面整体上的结构是html,下面又包含了head和body两部分。其中，head又包含了meta,title等4个内容。将上述结构画成树状图，如下：<br><img src="/images/spider5.jpg" srcset="/img/loading.gif" alt="" title="tree of html"><br>树形结构将会有助于我们遍历这个html文件。    </p><h2 id="Part-2：http协议"><a href="#Part-2：http协议" class="headerlink" title="Part 2：http协议"></a>Part 2：http协议</h2><p>http协议主要是讲我们如何访问网页的。<br>2.1 网络申请的响应过程<br>a. 浏览器通过DNS找到url对应的服务器，查找域名对应的ip地址；<br>b. 向目标地址的ip发送请求；<br>c. web服务器响应请求，返回html页面；<br>d. 浏览器解析html页面，并在显示端显示出来。    </p><p>2.2 url的分解(发了什么）<br>url的格式为：<br>scheme://host:port/path/?query-string = xxx # anchor<br>其中，scheme表示访问的协议，一般为http,https,ftp等；<br>host表示主机口，域名，例www.baidu.com；<br>port表示端口号，当访问一个服务器的时候，端口号默认为80；<br>path表示查找路径，指的是资源在服务器上的位置；<br>query-string表示要查询的字符串；<br>anchor表示锚点，也就是当前模块在页面上的第几部分。    </p><p>2.3 常用的请求方法（怎么发送的请求）<br>常用的请求方法有以下8种：<br><img src="/images/spider6.PNG" srcset="/img/loading.gif" alt="" title="tree of html"><br>其中，比较常用的有两种：post和get。   </p><p>2.4 请求头（发送过去，服务器怎么识别）<br>为了使得服务器知道这个页面请求是谁发来的，http协议会给请求加上请求头。常用的请求头参数如下：<br>a. User-Agent:浏览器名称；<br>b. Referer：表名当前这个请求是从哪个url过来的；<br>c. Cookie:用于区分不同的访问者；    </p><p>2.5 常见的响应代码（服务器识别之后，怎么响应）<br>当资源访问申请被提交给服务器之后，服务器会返回一个响应代码，用于描述当前的状态。常用的响应代码如下：<br>200：正常访问；<br>301：永久重定向；<br>302：临时重定向；<br>400：请求的内容在服务器上找不到；<br>403：服务器拒绝访问；<br>500：服务器内部错误。    </p><p>2.6 Chrome抓包工具（这个过程的调试工具）<br>针对chrome浏览器，这里使用“右键-检查”来获取当前页面的调试工具。<br>elements表示这个页面上显示的内容，当选中某一块的时候，会在页面上高亮提示，非常方便地帮助我们快速选择代码模块；<br>sources表示当前页面下内容的存储路径；<br>network通过抓取刷新页面时，不同资源的类型，大小，名字，状态等信息，能让我们对抓取与报错有非常直观的认识。   </p><h2 id="Part-3：爬虫的基本知识"><a href="#Part-3：爬虫的基本知识" class="headerlink" title="Part 3：爬虫的基本知识"></a>Part 3：爬虫的基本知识</h2><p>网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。 </p><p>网络爬虫的作用：<br>a. 抓取网页；<br>b. 数据存储；<br>c. 预处理；<br>d. 排名，提供检索服务等；   </p><p>网络爬虫的分类：<br>a. 按照目标来分：聚焦爬虫和通用网络爬虫；<br>聚焦爬虫是一个自动下载网页的程序，它根据既定的抓取目标，有选择的访问万维网上的网页与相关的链接，获取所需要的信息； 通用爬虫的目标性则不强，能够访问页面上的所有信息；<br>b. 按照规模来分：<br>小规模爬虫：主要爬取网页，速度不快；<br>中规模爬虫：爬取网站或者系列网站，对于速度有要求；<br>大规模爬虫：爬取全站，建立搜索引擎。    </p><p>网络爬虫的目标：在质量上，模拟用户通过浏览器对网页信息的获取；在速度上，越快越好。    </p><p>网络爬虫的风险：服务器上的数据有产权归属，若将网络爬虫爬取的数据用于牟利，可能存在法律风险。<br>如何避免呢？要遵循robots协议。</p><p>Robots协议是用来告诉爬虫哪些资源可以爬，哪些资源不可以爬。以京东的robots为例：</p><pre><code class="lang-https://www.jd.com/robots.txt```:">```User-agent: *                   # 表示所有人都可以爬Disallow: /?*                   # 但是不允许访问根节点中以？开头的路径Disallow: /pop/*.html           # 不允许访问/pop/下面的html内容Disallow: /pinpai/*.html?*      # 不允许访问/pinpai/下的html扩展内容User-agent: EtaoSpider          # 这个和下面四个是恶意爬虫Disallow: / User-agent: HuihuiSpider Disallow: / User-agent: GwdangSpider Disallow: / User-agent: WochachaSpider Disallow: /</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础6</title>
    <link href="/2020/02/23/MySQL%E5%9F%BA%E7%A1%806/"/>
    <url>/2020/02/23/MySQL%E5%9F%BA%E7%A1%806/</url>
    
    <content type="html"><![CDATA[<h1 id="第五篇：其余内容"><a href="#第五篇：其余内容" class="headerlink" title="第五篇：其余内容"></a>第五篇：其余内容</h1><p>本部分主要介绍MySQL基础中的其余内容，主要包含四大模块：视图，变量，存储过程和函数以及流程控制。<br>本章是数据库MySQL基础篇的最后一篇。        </p><h2 id="Part-1-视图"><a href="#Part-1-视图" class="headerlink" title="Part 1: 视图"></a>Part 1: 视图</h2><p>视图是将一部分MySQL代码封装起来，做成类似于函数的形式，进行调用。视图的内容是生成一张表格的逻辑，结果是一个虚拟表。    </p><blockquote><p>备注：视图只是逻辑，并不存储数据，当需要调用的时候，系统运行即可产生数据，组成虚拟表格。      </p></blockquote><h3 id="1-1-视图的创建"><a href="#1-1-视图的创建" class="headerlink" title="1.1 视图的创建"></a>1.1 视图的创建</h3><p>视图创建的语法如下：<br>createview 视图名<br>as<br>DQL查询语言；    </p><p>例1：查询员工表employees中员工邮箱名字包含字母a的员工的姓名，工号和工资<br>首先创建视图    </p><pre><code>createview easselect name, id, salaryfrom employeeswhere email like &#39;%a%&#39;;</code></pre><h3 id="1-2-视图的使用"><a href="#1-2-视图的使用" class="headerlink" title="1.2 视图的使用"></a>1.2 视图的使用</h3><p>视图创建完毕之后，会产生相关的字段，这里的字段与原来的表格已经不同了，新生成的字段取决于创建视图的时候的字段名。<br>例1：查询员工表employees中员工邮箱名字包含字母a的员工的姓名，工号和工资<br>然后使用视图    </p><pre><code>select * from e;</code></pre><h3 id="1-3-视图的修改"><a href="#1-3-视图的修改" class="headerlink" title="1.3 视图的修改"></a>1.3 视图的修改</h3><p>视图修改的语法有两种：     </p><ol><li>create or replace view 视图名 as DQL查询语言；    </li><li>alter view 视图名 as DQL查询语言；    <blockquote><p>备注：究其本质，视图的修改和创建没有什么区别，只是关键字换了。    </p></blockquote></li></ol><h3 id="1-4-视图的删除"><a href="#1-4-视图的删除" class="headerlink" title="1.4 视图的删除"></a>1.4 视图的删除</h3><p>删除视图的语法格式如下：<br>drop view 视图名；<br>这个语法可以一次删除多个，形式如下：<br>drop view 视图名1， 视图名2,…;<br>例2：删除例1创建的视图e</p><pre><code>drop view e;</code></pre><h3 id="1-5-视图的查看"><a href="#1-5-视图的查看" class="headerlink" title="1.5 视图的查看"></a>1.5 视图的查看</h3><p>查看视图的语法格式如下：<br>show create view 视图名；</p><h3 id="1-6-视图的更新"><a href="#1-6-视图的更新" class="headerlink" title="1.6 视图的更新"></a>1.6 视图的更新</h3><p>1.插入<br>插入语法与DML语言讲解的并无差别；<br>例3：在视图e中插入一个员工信息：张三，007,10000；    </p><pre><code>insert into e values(&#39;张三&#39;,&#39;007&#39;,10000);</code></pre><blockquote><p>备注：这里的插入会使得原始表的数据发生变化。</p></blockquote><p>2.修改<br>修改语法与DML语言讲解的并无差别；<br>例4：在视图e中修改员工张三的工资为12000；</p><pre><code>update e set salary = 12000 where name = &#39;张三&#39;;</code></pre><p>3.删除<br>删除语法与DML语言讲解的并无差别；<br>例5：在视图e中删除员工张三的信息；</p><pre><code>delete from e where name = &#39;张三&#39;;</code></pre><blockquote><p>备注：一般不建议更新视图，因为视图本身的保存为逻辑，更新数据的话，会给视图的保存带来困难。<br>备注：当具备以下几种情形时，不可以更新视图：   </p><ol><li>包含分组函数，distinct, group by, having, union 或者 union all;     </li><li>select 包含子查询;    </li><li>join    </li></ol></blockquote><h2 id="Part-2：变量"><a href="#Part-2：变量" class="headerlink" title="Part 2：变量"></a>Part 2：变量</h2><p>之前曾在MySQL基础4中介绍过MySQL的数据类型，这里对变量进行介绍。    </p><blockquote><p>备注：根据命名渠道，变量可以分为两种：系统变量和自定义变量。<br>根据作用范围，系统变量可分为：全局变量和会话变量<br>根据作用范围，自定义变量可分为：用户变量和局部变量    </p></blockquote><h3 id="2-1-系统变量"><a href="#2-1-系统变量" class="headerlink" title="2.1 系统变量"></a>2.1 系统变量</h3><p>是由系统定义在服务器层面的变量。    </p><ol><li>查看全局系统变量：show global variables;    </li><li>查看会话全局变量：show session variables;    </li><li>当需要增加查看的筛选条件时：<br>show global/session variables 筛选条件;    </li><li>查看某个系统指定的变量的值：select @@系统变量名；    </li><li>为某个系统变量赋值<br>set global/session 系统变量名 = 值；<br>set global/session.系统变量名 = 值；</li></ol><h3 id="2-2-自定义变量"><a href="#2-2-自定义变量" class="headerlink" title="2.2 自定义变量"></a>2.2 自定义变量</h3><p>是自己设置的，遵循“声明”-“赋值”-“使用”的顺序。<br>2.2.1 用户变量<br>用户变量是在整个会话中都可以使用的变量，           </p><ol><li>声明并初始化：set @变量名 = value 或者 set @变量名 ：= value 或者 select @用户变量名 ：= value;         </li><li>赋值语句：select 字段 into 变量名 from 表名；<br>2.2.2 局部变量<br>局部变量是在begin end中间的变量    </li><li>声明 declare 变量名 类型； 或者 declare 变量名 类型 default 值；    </li><li>赋值与用户变量的赋值一样    </li></ol><blockquote><p>备注：用户变量和局部变量的区别</p><ol><li>用户变量作用在整个会话中，而局部变量只能作用在begin end中；</li><li>用户变量的语法必须加@符号不用限定类型，而局部变量则不用加@但是需要限定类型；</li></ol></blockquote><h2 id="Part-3-存储过程和函数"><a href="#Part-3-存储过程和函数" class="headerlink" title="Part 3:存储过程和函数"></a>Part 3:存储过程和函数</h2><p>存储过程和函数，类似于Python中的方法，具有提高代码的可重复性，简化操作的优点。</p><h3 id="3-1-存储过程"><a href="#3-1-存储过程" class="headerlink" title="3.1 存储过程"></a>3.1 存储过程</h3><p>存储过程可以理解为一组预先编译好的sql语言集合，类似于批处理文件。<br>存储过程的优点如下：</p><ol><li>提高了代码的可重复性；</li><li>简化了操作；</li><li>减少了编译次数以及和服务器连接的次数，从而提高了效率；</li></ol><p>存储过程的创建语法：<br>create process 存储过程名（参数列表）<br>begin<br>      存储过程体（一般的SQL语法）<br>end    </p><blockquote><p>备注：参数列表中的参数包含三部分（参数模式， 参数名， 参数类型）<br>参数模式：in out inout分表表示传入参数，传出参数以及都可以的参数；<br>备注：如果存储过程体只有1句话，那么begin 和 end 可以省略；<br>存储过程体中的每句SQL语言必须加分号；<br>存储过程的结尾可以用delimiter重新设置；    </p></blockquote><p>存储过程的调用语法：call 存储过程名(实参列表）；<br>例6：向employees表中插入5条记录：    </p><pre><code>delimiter $  #首先设置结束标记create procedure pro1()begin      insert into employees(字段名） values(值）；end $</code></pre><p>例7：创建存储过程，实现输入女生名，返回她的男朋友的信息：    </p><pre><code>delimiter $    create procedure pro2(in name varchar(20))    begin           select boys.name          from boys         right join girls         on girls.boyfreind_id = boys.id         where girls.name = name;   end $   call pro2(&#39;小龙女&#39;)$;# 调用过程也要加上结尾符号</code></pre><p>例8：创建存储过程，实现输入女生名，返回她的男朋友的信息：     </p><pre><code>delimiter $create procedure pro3(in grils_name varchar(20)， out boys_name varchar(20))begin       select boys.name into boys_name      from boys      right join girls      on girls.boyfreind_id = boys.id      where girls.name = name;end $    call pro3(&#39;小龙女&#39;,@boyname)$ # 调用过程也要加上结尾符号    select @boyname$  # 查看用户变量的时候，需要加@</code></pre><p>例9：传入a和b两个值，将它们翻倍：    </p><pre><code>delimier $create procedure pro4(inout a int, inout b int)begin      set a = a*2;     set b = b*2;end $set @m = 10$set @n = 20$call pro4(@m, @n)$select @m $select @n $</code></pre><p>存储过程的删除：drop procedure 存储过程名；    </p><blockquote><p>备注：每次只能删除一个存储过程；    </p></blockquote><p>存储过程的查看：show creat procedure 存储过程名；</p><h3 id="3-2-函数"><a href="#3-2-函数" class="headerlink" title="3.2 函数"></a>3.2 函数</h3><p>与存储过程非常类似，也可以理解为一组SQL语言的批处理形式。<br>函数与存储过程的区别在于：函数必须有1个返回值，存储过程对返回值不做要求。    </p><p>函数的创建语法：<br>create function 函数名(参数列表) returns 返回类型<br>begin<br>      函数体<br>end    </p><blockquote><p>备注：参数列表包含两部分：参数名，参数类型；<br>备注：函数体必须要有return命令，可以不放在函数体的最后；<br>备注：依然可以通过设置delimiter $设置结尾； </p></blockquote><p>例10：根据员工表employes返回公司的员工个数:</p><pre><code>create function numCounting() returns intbegin     declare c int default 0;    select count(*) into c    from emplpoyees;    return c;end $select numCounting() $ # 调用的时候，直接用select</code></pre><p>例11：根据员工名返回他的工资:</p><pre><code>create function salaryFind(name varchar(20)) returns doublebegin       sel @sal = 0;      select salary into @sal      from emplpoyees      where employees.name = name;      return @sal;end $select salaryFind(&#39;张三&#39;) $ #调用</code></pre><p>函数的查看：show create function 函数名;<br>函数的删除：drop function 函数名；      </p><h2 id="Part-4-流程控制简介"><a href="#Part-4-流程控制简介" class="headerlink" title="Part 4:流程控制简介"></a>Part 4:流程控制简介</h2><p>之前在C++或者Python中学到的流程为：顺序流程，分支流程，循环流程。在这里，流程也一样。</p><h3 id="4-1-分支结构"><a href="#4-1-分支结构" class="headerlink" title="4.1 分支结构"></a>4.1 分支结构</h3><ol><li>if函数<br>语法：if（表达式1， 表达式2， 表达式3）<br>与c++三元结构组一致，表达式1成立则执行2，否则执行3；       </li><li>case函数<br>case有两种用法：<br>类型1：<br>case 变量/表达式/字段<br>when 要判断的值 then<br>…<br>else 操作<br>end case;<br>类型2：<br>case<br>when 要判断的条件1 then 操作1<br>when 要判断的条件2 then 操作2<br>…<br>else 操作n<br>end case;<br>例12：输入成绩，判断成绩等级：    <pre><code>create procedure scoreLevel(in score int)begin   case   when score&gt;90 then select &#39;A&#39;;  when score&gt;=80 then select &#39;B&#39;;  when score&gt;=60 then select &#39;C&#39;;  else select &#39;D&#39;;  endend $</code></pre></li><li><p>if结构<br>if结构用于多重分支结构，语法如下：<br>if 要判断的条件1 then 操作1；<br>elseif 要判断的条件2 then 操作2；<br>…<br>end if;<br>这种if结构要用在begin end内部。<br>例12：输入成绩，判断成绩等级：   </p><pre><code>create function scoreLevel(score int) returns charbegin   if score&gt;=90 then return &#39;A&#39;;  elseif score&gt;=80 then return &#39;B&#39;;  elseif score&gt;=60 then return &#39;C&#39;;  else return &#39;D&#39;;  end if;    end $</code></pre><h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><p>可能出现的形式：while loop repeat<br>循环控制：iterate类似于continue, leave类似于break;</p></li><li><p>while<br>语法：<br>while 循环条件 do<br>循环体<br>end while    </p></li><li><p>loop<br>语法：<br>loop<br>循环体<br>end loop;       </p></li><li><p>repeat<br>语法：<br>repeat<br>循环体<br>until 结束循环的条件<br>end repeat    </p></li></ol><p>例13：向员工表employees中多次插入张三的信息：    </p><pre><code>create procedure pro6(in insertCount int)begin      declare i int default 1;     while i &lt; insertCount do         insert into employees(&#39;name&#39;, &#39;salary&#39;) values(&#39;张三&#39;,&#39;1000&#39;)         set i = i + 1     end while;end $</code></pre><blockquote><p>备注：三种循环结构的比较<br>while 先判断后执行； repeat先执行后判断； loop没有限制的死循环，必须加限制条件；    </p></blockquote><h2 id="Part-5-MySQL基础结语"><a href="#Part-5-MySQL基础结语" class="headerlink" title="Part 5:MySQL基础结语"></a>Part 5:MySQL基础结语</h2><p>MySQL是必备技能，基础部分的内容比较好学。后续将继续更新MySQL高级的内容。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础5</title>
    <link href="/2020/02/23/MySQL%E5%9F%BA%E7%A1%805/"/>
    <url>/2020/02/23/MySQL%E5%9F%BA%E7%A1%805/</url>
    
    <content type="html"><![CDATA[<h1 id="第五篇：事务控制语言TCL"><a href="#第五篇：事务控制语言TCL" class="headerlink" title="第五篇：事务控制语言TCL"></a>第五篇：事务控制语言TCL</h1><p>transaction control language,事务控制语言。    </p><h2 id="Part-1-TCL的基本知识"><a href="#Part-1-TCL的基本知识" class="headerlink" title="Part 1: TCL的基本知识"></a>Part 1: TCL的基本知识</h2><p>一个或者一组sql语言组成一个事务，这个事务具有如下特点：    </p><ol><li>原子性：事务是不可分割的；    </li><li>一致性：使得数据从一个状态变换到另一个状态；    </li><li>隔离性：一个事务执行的过程中，不能被其他事务干扰；   </li><li>持久性：事务执行的结果，是存储下来的。   </li></ol><p>事务的创建可以分为两种：        </p><ol><li>隐式的创建：一般以一行语法为主，没有明显的开始或者结束信号；    </li><li>显式的创建：事务有明显的开启与结束的标志，但前提是要关闭自动提交功能。<br>备注：关闭自动提交功能的关键字是： set autocommit = 0;</li></ol><p>显式的创建的语法：<br>start transaction;  # 首先写开启事务的标志<br>sql language；      # 然后写sql语言，组成一个事务<br>commit;             # 通知系统，提交事务<br>备注：如果有需要，可以写回滚事务。 </p><h2 id="Part-2：MYSQL的隔离级别"><a href="#Part-2：MYSQL的隔离级别" class="headerlink" title="Part 2：MYSQL的隔离级别"></a>Part 2：MYSQL的隔离级别</h2><p>MySQL支持的隔离级别：   </p><ol><li>read uncommitted(读取未提交内容);  所有事务都可以看到其他未提交事务的执行结果。读取未提交的数据，也被称之为脏读（Dirty Read）。     </li><li>Read Committed（读取提交内容);  一个事务只能看见已经提交事务所做的改变,支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。    </li><li>Repeatable Read（可重读); 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这会导致幻读, 指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。    </li><li>Serializable（可串行化); 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。但是牺牲了性能。</li></ol><p>如何设置数据库的隔离级别？<br>语法：set session transcation isolation level 前述隔离级别；</p><h2 id="Part-3-回滚"><a href="#Part-3-回滚" class="headerlink" title="Part 3:回滚"></a>Part 3:回滚</h2><p>回滚是指在误操作之后，将数据恢复到原来某个状态的方法。<br>首先要设置一个回滚点，记录当下的状态。<br>语法：savepoint 保存点名;<br>之后即可对现有的操作进行回滚。<br>例1：展示回滚点的使用：    </p><pre><code>set autocommit = 0;    start transcation;    delete from book where price = 20;savepoint point1;delete from book where price = 30;rollback to point1;</code></pre><p>备注：回滚点的使用方法类似于回滚点之后的操作在回滚之后被撤销了。    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础4</title>
    <link href="/2020/02/13/MySQL%E5%9F%BA%E7%A1%804/"/>
    <url>/2020/02/13/MySQL%E5%9F%BA%E7%A1%804/</url>
    
    <content type="html"><![CDATA[<h1 id="第四篇：数据定义语言DDL"><a href="#第四篇：数据定义语言DDL" class="headerlink" title="第四篇：数据定义语言DDL"></a>第四篇：数据定义语言DDL</h1><p>数据定义语言主要解决数据库的创建及删除和表格的结构的问题。其中，库和表格的操作都是创建，修改和删除。但是，为了更加清楚地显示表格的结构，这里还将对MySQL的常见数据形式以及常见约束进行说明。</p><h2 id="Part-1-数据库的管理"><a href="#Part-1-数据库的管理" class="headerlink" title="Part 1:数据库的管理"></a>Part 1:数据库的管理</h2><p>数据库的主要操作依然是创建，删除，修改。</p><p>数据库的创建的语法如下：<br>creat database 数据库名；    </p><blockquote><p>备注：数据库名不可与已经有的数据库名重复。<br>为了解决这个问题，创建如下的格式：<br>creat database if not exists 数据库名；<br>例1：创建数据库books：    </p><pre><code>creat database if not exists books;</code></pre></blockquote><p>数据库的修改：原则上一般不修改数据库，因为可能造成数据的丢失等问题，所以如果想修改的话，直接创建一个新的数据库即可。    </p><p>数据库的删除的语法如下：<br>drop database 数据库名；<br>例2：删除数据库books：     </p><pre><code>drop database books;</code></pre><h2 id="Part-2-常见的数据类型"><a href="#Part-2-常见的数据类型" class="headerlink" title="Part 2:常见的数据类型"></a>Part 2:常见的数据类型</h2><p>这一部分主要总结数据库的常见的数据类型，为表的结构打下基础。常见的数据类型主要包括以下几种：     </p><ol><li>数值型：整型+小数型</li><li>字符型</li><li>日期型</li></ol><h3 id="第一部分：数值型"><a href="#第一部分：数值型" class="headerlink" title="第一部分：数值型"></a>第一部分：数值型</h3><p>数值型包括整型和小数型。先从整型说起。<br>tinyint   1个字节<br>smallint  2个字节<br>mediumint 3个字节<br>int       4个字节<br>bigint    8个字节 </p><blockquote><p>备注：       </p><ol><li>一般情况下，用int足够应对对整数的要求；如果数值超过了最大长度，那么就会将这个数值设置为临界值。     </li><li>在创建表格时，设置的int的不同类型，都是有符号的数字，也就是可以表示负数；如果需要设置为无符号的数字的话，需要在不同类型的int后加上关键字unsigned.       </li><li>一般int的长度会根据上面的不同类型来默认设置，如果需要强制设置长度的话，使用int(6)这种格式进行设置，其中6表示这种类型想要设置的长度。    </li><li>如果需要在表格中设置定宽的values的话，需要在int后unsigned前加入zerofill这个关键字。</li></ol></blockquote><p>小数型：<br>小数型包含两种：浮点型和定点型。<br>浮点型：float(M,D), double(M,D)<br>其中，D表示小数点后面的小数的宽度，如果不够，补0；如果超过，则四舍五入；<br>M表示整数+小数的总长度，如果不写M和D的时候，插入什么都行；<br>定点型：dec(M,D),decimal(M,D)<br>其中，D表示小数点后面的小数的宽度，如果不够，补0；如果超过，则报错；<br>M表示整数+小数的总长度，如果不写M和D的时候，M默认为10，D默认为0；</p><h3 id="第二部分：字符型"><a href="#第二部分：字符型" class="headerlink" title="第二部分：字符型"></a>第二部分：字符型</h3><p>较短的字符型采用char和varchar进行保存，较长的字符型数据使用text和blob进行保存。需要注意的是，blob保存的是2进制的数据。<br>1.char(M)表示长度为M个字符数的字符型，M的取值可以为1-255；<br>2.varchar(M)表示长度为M个字符数的字符型，M的取值可以为1-255；    </p><blockquote><p>备注：char和varchar的区别在于varchar可以灵活调用，使用M以内的任意长度的字符型，比较省空间；char设置的M个长度，调用的就是M长度的空间，不够灵活。此外，varchar()中的M不可省略，char()中的M可以省略，默认值为1.    </p></blockquote><p>3.enum()用于保存枚举；<br>4.set()用于保存集合。   </p><h3 id="第三部分：日期型"><a href="#第三部分：日期型" class="headerlink" title="第三部分：日期型"></a>第三部分：日期型</h3><p>MySQL要求日期型的变量用单引号’引起来。<br>日期型主要有以下几种：    </p><ol><li>date， 使用4个字节， 最小时间：1000-01-01， 最大时间：9999-12-31；    </li><li>datetime, 使用8个字节，最小时间：1000-01-01 00:00:00，最大时间：9999-12-31 23:59:59；    </li><li>timestamp, 使用4个字节，最小时间：19700101 080001， 最大时间：2038年的某个时刻；timestamp受时区的影响；    </li><li>time，使用3个字节，最小时间：-838:59:59，最大时间：838:59:59</li><li>year，使用1个字节，最小时间：1091，最大时间：2155；    </li></ol><h2 id="Part-3-常见的约束总结"><a href="#Part-3-常见的约束总结" class="headerlink" title="Part 3:常见的约束总结"></a>Part 3:常见的约束总结</h2><p>为了保证表格中的数据的稳定性和有效性，这里创建了约束的做法。<br>约束可以分为以下6种：    </p><ol><li>非空约束：该字段名下必须有内容；    </li><li>默认约束：该字段名存在默认值；    </li><li>主键约束：该字段名下的值不可以为空，并且不能重复；    </li><li>唯一约束：该字段名下的值可以为空，但是不能重复；    </li><li>检查约束：MySQL中不支持；    </li><li>外键约束：限制两个表之间的关系，用于引用对方表格中的某些信息；</li></ol><p>添加约束的时机：      </p><ol><li>创建表格时；   </li><li>修改表格时；    </li></ol><p>按照添加的约束的作用范围可以分为：    </p><ol><li>列级约束：都可以，但是外键约束无效果；    </li><li>表级约束：不可以加非空约束和默认约束，其余约束可以写；    <blockquote><p>备注：列级约束主要写在字段名之后即可，表级约束写在所有的列级约束之后，用于关联不同表格之间的关系；    </p></blockquote></li></ol><p>类型1：创建表格时添加列级约束<br>例3：在学生数据库student中创建表stuinfo：    </p><pre><code>creat database student；     use student;    creat table stuinfo(         id int primary key, # 其中id表示学号，由于学号不能是重复，也不能缺省，定义学号为主键约束；    stuName varchar(20) not null; # 其中stuName表示学生的姓名，由于不能缺省，可以重复，所以为非空约束；        gender char(1) check(gender = &#39;男&#39; or gender = &#39;女&#39;), # 其中性别是只有两种选项的字符，所以可以设置为检查约束；       seat_id int unique， #其中seat_id表示座位号，是不可重复，但是可以空缺的，所以设置为唯一性约束；         major_id int references major(id) # 其中major_id表示专业号码，类型为int,需要借助于专业表major来判断具体是什么单位；    );</code></pre><blockquote><p>备注：创建表格的时候，最后一行不需要加,号；        </p></blockquote><p>类型2：创建表格时添加表级约束<br>例4：在学生数据库student中创建表stuinfo：     </p><pre><code>creat database student；     use student;    creat table stuinfo(         id int,     stuName varchar(20)，        gender char(1),     seat_id int，         major_id int，    # 下面添加表级约束    constraint pk primary key(id),    constraint uq unique(seat_id),    constraint ck check(gender = &#39;男&#39; or gender = &#39;女&#39;),    constraint fk_stuinfo_major foreign key(majorid) references major(id)   );</code></pre><p>类型3：修改表格的时候添加列级约束<br>修改表格的时候，添加列级约束的语法如下：<br>alter table 表名 modify column 字段名 约束类型；<br>例5：将学生信息表stuinfo中学生姓名stuName修改为非空约束：     </p><pre><code>alter table stuinfo modify column stuName varchar(20) not null;</code></pre><p>例6：将学生信息表stuinfo中学生年龄age修改为默认约束，默认18岁：    </p><pre><code>alter table stuinfo modify column age int default 18;</code></pre><p>例7：将学生信息表stuinfo中学生学号id修改为主键约束：        </p><pre><code>alter table stuinfo modify column id int primary key;</code></pre><p>例8：将学生信息表stuinfo中学生座位号seat_id修改为唯一约束：        </p><pre><code>alter table stuinfo modify column seat_id int unique;</code></pre><blockquote><p>备注：修改表格时，只能添加这4种表级约束；    </p></blockquote><p>类型4：修改表格的时候添加表级约束<br>修改表格的时候，添加表级约束的语法如下：<br>alter table 表名 modify add constraint 约束名 约束类型(字段名)；<br>例9： 将学生信息表stuinfo中学生学号id修改为主键约束：      </p><pre><code>alter table stuinfo add primary key(id);</code></pre><p>例10：将学生信息表stuinfo中学生座位号seat_id修改为唯一约束：        </p><pre><code>alter table stuinfo add unique(seat_id);</code></pre><p>例11：将学生信息表stuinfo中学生专业号major_id修改为外键约束：   </p><pre><code>alter table stuinfo add foreign key(major_id) references major(id);</code></pre><p>补充：删除约束指的是，将约束变为之前的样子即可，就是上述添加约束的逆过程。<br>例12：删除学生信息表stuinfo中学生姓名stuName的非空约束：    </p><pre><code>alter table stuinfo modify column stuName varchar(20) null;</code></pre><p>例13：删除学生信息表stuinfo中学生年龄age的默认约束：    </p><pre><code>alter table stuinfo modify column age int;</code></pre><p>例14：删除学生信息表stuinfo中学生学号id的主键约束：    </p><pre><code>alter table stuinfo drop primary key;</code></pre><p>例15：删除学生信息表stuinfo中学生座位号seat_id的唯一约束：    </p><pre><code>alter table stuinfo drop index seat_id;</code></pre><p>例16：删除学生信息表stuinfo中学生专业号major_id的外键约束：    </p><pre><code>alter table stuinfo drop foreign key majpr_id;</code></pre><blockquote><p>备注：主键和唯一键的区别：<br>主键是唯一的，不可以为空，每个表格中至多1个，可以组合，但不推荐；<br>唯一键是唯一的，但是可以空，每个表格中可以有很多个，可以组合，但不推荐。    </p></blockquote><h2 id="Part-4-表格的管理"><a href="#Part-4-表格的管理" class="headerlink" title="Part 4:表格的管理"></a>Part 4:表格的管理</h2><p>类似于数据库的管理，表格的管理主要是添加，修改，删除，不过还多了一个复制。 </p><h3 id="表格的添加"><a href="#表格的添加" class="headerlink" title="表格的添加"></a>表格的添加</h3><p>表格的创建的语法结构如下：<br>creat table 表名(<br>    字段名 字段的类型 字段的约束，<br>    字段名 字段的类型 字段的约束，<br>    …<br>)；    </p><p>例17： 创建一个表book：   </p><pre><code>create table book(    id int,    bname varchar(20),    author_id int,    publish_date Datetime);</code></pre><h3 id="表格的修改"><a href="#表格的修改" class="headerlink" title="表格的修改"></a>表格的修改</h3><p>类型1：修改字段名<br>语法：alter table 表名 change column 旧字段名 新字段名 类型；    </p><blockquote><p>备注：由于有了类型，这个语法也可以更新字段的类型。<br>例18：将表格book中的发布日期修改为pub_date：    </p><pre><code>alter table book change column publish_date pub_date;</code></pre></blockquote><p>类型2：修改字段的类型或者约束<br>语法：alter table 表名 modify column 字段名 类型名；<br>例19：将表格book中的发布日期publish_date的类型修改为日期戳：    </p><pre><code>alter table book modify column publish_date timestamp;</code></pre><p>类型3：添加新字段<br>语法：alter table 表名 add column 字段名 类型名;<br>例20：在表格book中添加新的字段price，类型为double；    </p><pre><code>alter table book add column price double;</code></pre><p>类型4：删除字段<br>语法：alter table 表名 drop column 字段名;<br>例21：删除表格book中的字段price：    </p><pre><code>alter table book drop column price;</code></pre><p>类型5：修改表名<br>语法：alter table 旧表名 rename to 新表名；<br>例22：将表格book改名为books:    </p><pre><code>alter table book rename to books;</code></pre><h3 id="表格的删除"><a href="#表格的删除" class="headerlink" title="表格的删除"></a>表格的删除</h3><p>语法：drop table if exists 表名；</p><h3 id="表格的复制"><a href="#表格的复制" class="headerlink" title="表格的复制"></a>表格的复制</h3><p>表格的复制存在两种：       </p><ol><li>表格结构的复制；   </li><li>表格结构+内容的复制；    </li></ol><p>表格结构的复制的语法：<br>create table 新表名 like 旧表名；<br>这种复制只有表格的架构，没有表格的内容；       </p><p>表格内容+结构的复制语法：<br>create table 新表名 select * from 旧表名；<br>这种复制方法能够将旧表格的所有内容都复制过来。       </p><p>复制表格结构+部分内容的语法：<br>create table 新表名 select * from 旧表名 where 筛选条件;<br>先筛选后复制。    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础3</title>
    <link href="/2020/02/13/MySQL%E5%9F%BA%E7%A1%803/"/>
    <url>/2020/02/13/MySQL%E5%9F%BA%E7%A1%803/</url>
    
    <content type="html"><![CDATA[<h1 id="第三篇：数据操纵语言DML"><a href="#第三篇：数据操纵语言DML" class="headerlink" title="第三篇：数据操纵语言DML"></a>第三篇：数据操纵语言DML</h1><p>数据操纵语言DML与数据查询语言DQL之间的主要区别在于：DML语言是对表格中的数据进行改变，DQL语言只是查询表格中的数据。<br>改变就包括主要的三种：增加，删除，修改。</p><h2 id="Part1-增加"><a href="#Part1-增加" class="headerlink" title="Part1: 增加"></a>Part1: 增加</h2><p>增加是向表格中增加行，也就是增加数据量。增加并不改变原来表格数据的结构。<br>语法格式如下：<br>insert into 表名(字段名1，字段名2，…,字段名n) values(值1，值2，…，值n);     </p><blockquote><p>备注：值与列名要保持对应关系</p></blockquote><p>例1：向女生表girls中添加一行唐艺昕的值：    </p><pre><code>insert into girls(id, name, sex, borndate, phone-number, photo, boyfriend_id)  values(12, &#39;唐艺昕&#39;, F, &#39;1990-04-23&#39;, &#39;18988888888&#39;, null, 2);</code></pre><blockquote><p>备注：其中null表示没有照片信息，那么直接填写null即可。     </p></blockquote><p>对于值可以为null的字段名，应该如何应对？<br>有两种方法：    </p><ol><li>在表名后写上该字段名，然后在后续的值中写上null；    </li><li>在表名后面不写该字段名，然后再值中也不写；<br>总的来说就是前后保持一致。这两种方法的区别如下：    </li><li>方式1可以支持一次性插入多行，但是方式2不支持；</li><li>方式1支持子查询，方式2不支持。</li></ol><blockquote><p>备注：    </p><ol><li>插入的值的格式要与字段的要求格式保持一致；    </li><li>只有声明可以填写null的字段名才可以填null，并有两种方式；    </li><li>字段名的顺序可以调整，不用与表格中保持一致，但是值与字段名要保持一致；  </li></ol></blockquote><h2 id="Part2-删除"><a href="#Part2-删除" class="headerlink" title="Part2: 删除"></a>Part2: 删除</h2><p>删除是向表格中减少行，也就是减少数据量。删除并不改变原来表格数据的结构。<br>语法格式如下：<br>delete from 表名 where 筛选条件    </p><p>例2：删除女生表girls中手机号以9结尾的女生信息：    </p><pre><code>delete from girls where phone-number like &#39;%9&#39;;</code></pre><p>如果是在多个表中删除信息的话，需要考虑到表格之间的关联属性，用到之前的连接方式。<br>例3：删除女生表girls中男朋友是张无忌的女生的信息:     </p><pre><code>deletefrom girlsjoin boyson boys.id = girls.boyfirend_id    where boys.name = ’张无忌&#39;;</code></pre><p>如果需要删除整个表格的话，需要用到truncate。尽管delete也可以实现对于表格中的元素的全部删除，但是trancate可以更加高效地完成同样的工作。    </p><h2 id="Part3-修改"><a href="#Part3-修改" class="headerlink" title="Part3: 修改"></a>Part3: 修改</h2><p>修改是改变表格中已经有的数据的字段的信息。修改并不改变原来表格数据的结构。<br>语法格式如下：<br>update 表名 set 字段名 = value where 筛选条件；<br>例4：修改女生表girls中姓唐的女生的手机号码为13888888888:    </p><pre><code>update grils set phone-number = 13888888888 where name like &#39;唐%&#39;;</code></pre><p>如果需要借助于多个表格的信息的话，需要用到表格之间的关联条件。<br>例5：修改女生表girls男朋友编号不在男生表boys中的女生的男朋友编号为2：    </p><pre><code>update girlsleft outer join boyson girls.boyfriend_id = boys.idset girls.boyfriend_id = 2where boys.name is Null;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础2</title>
    <link href="/2020/02/10/MySQL%E5%9F%BA%E7%A1%802/"/>
    <url>/2020/02/10/MySQL%E5%9F%BA%E7%A1%802/</url>
    
    <content type="html"><![CDATA[<h1 id="第二篇：数据查询语言DQL"><a href="#第二篇：数据查询语言DQL" class="headerlink" title="第二篇：数据查询语言DQL"></a>第二篇：数据查询语言DQL</h1><h2 id="Part1-基础查询"><a href="#Part1-基础查询" class="headerlink" title="Part1: 基础查询"></a>Part1: 基础查询</h2><p>核心的关键查询词：select<br>它可以用于查询表中的字段、常量、表达式、函数等，查询结果是一个<strong>虚拟表格</strong>。</p><p>查询常量的方法：<br>select 常量；<br>例1：查询”jerry” </p><pre><code>select &quot;jerry&quot;;</code></pre><blockquote><p>备注：查询的常量，可以是数字，字符串等常量格式。         </p></blockquote><p>查询表格中1个字段的语法：<br>select 字段名 from 表格名;<br>例2：从员工表employees中查询员工的姓名：  </p><pre><code>select name from employees;</code></pre><p>查询表格中多个字段的语法：<br>select 字段名1， 字段名2， …, 字段名n from 表名；<br>例3：从员工表employees中查询员工的名字和工号：  </p><pre><code>select name, id from employees;</code></pre><p>给查询的字段起别名：<br>select 字段 as 别名 from 表名;<br>例4：从员工表employees中查询员工的姓名，并命名为”姓名”显示：  </p><pre><code>select name &quot;姓名&quot; from employees;</code></pre><blockquote><p>备注: as可加可不加；</p></blockquote><p>查询函数：<br>select 函数；<br>例5：查询当前mysql的版本号:    </p><pre><code>select version();</code></pre><h2 id="Part2-条件查询"><a href="#Part2-条件查询" class="headerlink" title="Part2: 条件查询"></a>Part2: 条件查询</h2><p>基本语法如下：<br>select 字段 from 表名 where 筛选条件;<br>执行顺序：</p><ol><li>首先检查from 表名中的表格是否存在；    </li><li>然后检查where中的筛选条件;    </li><li>最后将结果显示select出来；    </li></ol><p>按照条件表达式筛选：<br>补充：条件预运算符有 &gt; &lt; = &lt;&gt; &gt;= &lt;=<br>例6：查询员工表employees中工资&gt;10000元的员工的姓名：<br>select name from employees where salary&gt;10000;</p><p>按照逻辑表达式筛选：<br>补充：逻辑运算符有 &amp; | ！ and or not<br>例7：查询员工表employees中工资&gt;10000元且工号小于100的员工的姓名:    </p><pre><code>select name    from employees    where salary &gt; 10000 and id &lt; 100;</code></pre><p>按照模糊查询的方式筛选：<br>补充：模糊查询方法有 like, between and, in, is null<br>例8：查询员工表employees中邮箱名字包含字母e的员工的姓名:     </p><pre><code>select name    from employees    where email like &quot;%e%&quot;;</code></pre><p>例9：查询员工表employees中邮箱的第3个字母是e的员工的姓名:   </p><pre><code>select name   from employees    where email like &quot;__e%&quot;;</code></pre><blockquote><p>备注：%表示字符型通配符，可以表示0个或者多个；<br>_也表示字符型通配符，但是只能表示一个；<br>例10：查询员工表employees中工资在8000-10000的员工的姓名：    </p><pre><code>select name    from employees    where salary between 8000 and 10000;</code></pre><p>备注：between and 的结构中，第一个数字要比第二个小；<br>例11：查询员工表employees中工种是”IT”,”VP”,”PRSE”的员工姓名：    </p><pre><code>select name    from employees    where job_title in (&quot;IT&quot;, &quot;VP&quot;, &quot;PRES&quot;);</code></pre></blockquote><h2 id="Part3-排序查询"><a href="#Part3-排序查询" class="headerlink" title="Part3: 排序查询"></a>Part3: 排序查询</h2><p>排序查询的语法如下：<br>select 字段名 from 表名 where 筛选条件 order by 排序条件 排序方法；    </p><blockquote><p>备注：排序方法有两种 asc代表升序排列，可省略； desc代表降序排列，不可省略。<br>其中语法执行的顺序为：       </p><ol><li>from 表名    </li><li>where 筛选条件    </li><li>select 字段名    </li><li>order by 排序条件 排序方法；    </li></ol></blockquote><p>单次排序：<br>例12：将员工表employees中的员工姓名按照工资的降序排列：   </p><pre><code>select name     from employees    order by salary desc;</code></pre><p>多次排序：<br>多次排序是指在主排序中出现排序相同的时候的次排序方案。<br>例13：将员工表employees中的员工先按照工资降序排序，再按照工号升序排序： </p><pre><code>select name    from employees    order by salary desc, id asc;</code></pre><h2 id="Part4-常见函数"><a href="#Part4-常见函数" class="headerlink" title="Part4: 常见函数"></a>Part4: 常见函数</h2><h3 id="A-字符函数"><a href="#A-字符函数" class="headerlink" title="A. 字符函数"></a>A. 字符函数</h3><p>1.length();输出括号内有几个字节；备注：1个汉字3个字节，1个字母1个字节（utf8)<br>2.contact();拼接字符，例如：contact(last_name,’-‘,first_name);<br>3.upper();小写字母变大写字母；<br>4.lower();大写字母变小写字母；<br>5.substr();输出字符中的一部分，使用方法：<br>  substr(string, a, b)表示从字符串string中的第a个字符开始，到第b个字符，<br>  如果只有一个字母，则默认到最后；    </p><blockquote><p>备注：这里是字符，并不是字节；<br>备注：mysql中的字符是从1开始，而非0； </p></blockquote><p>6.instr();返回目标出现的第一个位置，使用方法：<br>   instr(string, a)输出a在string中第一次出现的位置;<br>7.trim();去掉前后的字符，使用方法：<br>   例14：trim(‘   张翠山   ‘)输出’张翠山’，前后的’ ‘被去掉了；<br>   例15：trim(‘a’ from ‘aaa张翠山aaa’）输出’张翠山’，前后的’a’被全掉了;<br>8.lpad()；字符串的左边用指定字符进行填充，使用方法：<br>   例16：lpad(‘张翠山’,10,’a’)输出’aaaaaaa张翠山’，其中10表示输出总长度；<br>9.rpad()；字符串的右边用指定字符进行填充，使用方法：<br>   例17：rpad(‘张翠山’,10,’a’)输出’张翠山aaaaaaa’，其中10表示输出总长度；   </p><blockquote><p>备注：如果本身字符串的长度就大于输出的总长度的话，则输出保持不变；</p></blockquote><p>10.repalce();替换字符串，用法如下：<br>   replace(string, a, b)将字符串中的a用b替换；   </p><h3 id="B-数学函数"><a href="#B-数学函数" class="headerlink" title="B. 数学函数"></a>B. 数学函数</h3><p>1.round();四舍五入函数；<br>2.ceil();向上取整函数，也就是返回大于等于当前这个输入数据的最小整数；<br>3.floor();向下取整函数，也就是返回小于等于当前这个输入数据的最大整数；<br>4.truncate();截断函数，干掉小数点后面的数字，用法如下：<br>   例18：truncate(1.699,1)输出1.6<br>5.mod();取余函数,用法如下：<br>   例19：mod(10,3)输出1    </p><blockquote><p>备注：公式为mod(a,b) = a-a/b*b    </p><h3 id="C-日期函数"><a href="#C-日期函数" class="headerlink" title="C. 日期函数"></a>C. 日期函数</h3><p>1.now();返回当前的系统日期+时间，格式为：’2020-02-09 14:37:18’;<br>2.curdate(); 返回当前的系统日期,格式为：’2020-02-09’;<br>3.curtime(); 返回当前的系统时间,格式为：’14:37:18’;<br>4.分别获取系统的年月日：<br>   select year(now());<br>   select month(now());<br>   select day(now());<br>5.str_to_date();将日期格式转换为指定格式：<br>   例20：str_to_date(‘9-13-1999’,’%m-%d-%y’);输出为’2019-09-13’，其中‘%m-%d-%y’是通知这个函数，你输入的时间格式中，哪个是年月日，然后再按照标准化输出；<br>6.date_fromat();将日期转换为字符：<br>   例21：date_format(now(),’%y年%m月%d日’)；输出为’20年02月09日’;<br>备注：因为输出写的是y，所以是20年；如果写为Y，就是2020年；<br>备注：看清楚函数，是date_format而不是date_formate   </p><h3 id="D-流程控制函数"><a href="#D-流程控制函数" class="headerlink" title="D. 流程控制函数"></a>D. 流程控制函数</h3><ol><li>if函数<br>语法结构为：if(exp1, exp2, exp3)如果exp1真，那么执行exp2；否则执行exp3；</li><li>case函数<br>语法1：switch (变量)<br>{<br>case 常量： 语句， break<br>…<br>default 语句<br>}<br>语法2：<br>case 字段或者表达式<br>when 常量1 then 语句1<br>…<br>else 语句n（默认情况)</li></ol></blockquote><h2 id="Part5-分组函数"><a href="#Part5-分组函数" class="headerlink" title="Part5: 分组函数"></a>Part5: 分组函数</h2><ol><li>sum(); 求和</li><li>avg(); 均值；</li><li>max(); 最大值;</li><li>min(); 最小值;</li><li>count(); 统计函数;<br>例22：求员工表employees中所有员工的平均工资：        <pre><code>select avg(salary) from employees;</code></pre>例23：求员工表employees中所有员工的工资之和：    <pre><code>select sum(salary) from employees;</code></pre>例24：统计员工表employees中共有多少名员工:    <pre><code>select count(*) from employees;</code></pre></li></ol><h2 id="Part6-分组查询"><a href="#Part6-分组查询" class="headerlink" title="Part6: 分组查询"></a>Part6: 分组查询</h2><p>分组查询的语法如下：<br>select 字段名<br>from 表名<br>where 筛选条件<br>group by 分组条件<br>order by 排序条件 排序方法<br>执行的顺序如下：</p><ol><li>from 表名    </li><li>where 筛选条件    </li><li>group by 分组条件   </li><li>select 字段名    </li><li>order by 排序条件 排序方法   </li></ol><p>例25：查询员工表employees中的每个工种的最高工资：     </p><pre><code>select max(salary)    from employees  group by job_id;</code></pre><p>例26：查询员工表employees中哪个部门的员工数目&gt;2：    </p><pre><code>select count(*)   from employees        group by department_id        having count(*)&gt;2;</code></pre><p>备注：having 表示在上述的表格的结果中进行筛选，从某个表+筛选条件的角度来说，生成的是虚拟表格，having 就是在这个基础上进行筛选的。<br>备注：加了having之后的执行顺序是：</p><ol><li>from 表名;</li><li>where 筛选条件；</li><li>group by 分组条件；</li><li>having 筛选条件；</li><li>select 字段；</li><li>order by 排序条件 排序方法；</li></ol><p>联合查询：<br>例27：查询员工表employees中每个部门每个工种的平均工资：<br>首先要理解题意，不同部门是存在不同的工种的，所以要分类执行，输出结果按照笛卡尔排序的方法；</p><pre><code>select avg(salary)    from employees    group by depatrtment_id, job_id;</code></pre><blockquote><p>备注：这里的department_id， job_id的形式，已经将两者搭配在一起了，形成了想要的结果。</p></blockquote><h2 id="Part7-连接查询"><a href="#Part7-连接查询" class="headerlink" title="Part7: 连接查询"></a>Part7: 连接查询</h2><p>连接查询，相较于上述的查询方式的主要区别如下：<br>上述查询方式是只用一张表的信息就足够了<br>连接查询希望借助不同表格的信息，对查询的数据进行优化    </p><p>连接查询的语法如下：<br>select 字段名<br>from  表格1<br>[type]  join 表格2<br>on 连接条件<br>where 筛选条件<br>group by 分组条件<br>having 筛选条件<br>order by 排序条件 排序方法<br>执行顺序记忆方法如下：<br>表格1 [type] join 表格2 on 连接条件<br>形成了一个新的表格，其余方法参考之前的内容</p><p>type的类型1：等值连接<br>这种方法是指相互连接的两个表格之间的关系是平等的，此时type=inner，可以省略<br>例28：根据员工表employees和部门表department，查询工资&gt;10000的员工所在的部门的名字：     </p><pre><code>select departmnent_name    from employees  ejoin departments  d   on e.department_id = d.department_idwhere salary&gt;10000;</code></pre><blockquote><p>备注：如果需要去重，请使用函数dinstinct();</p></blockquote><p>实现三表连接：<br>例29：查询员工名，部门名和所在的城市：    </p><pre><code>select name, department_name, city        from departments d    join employees e    on e.department_id = d.department_id    join locations l      on d.location_id = l.location_id;</code></pre><blockquote><p>备注：这里是按照多重的join的方式，将不同的表格联合在一起；要做到能够和另外两个表格都连接的表格放在最前面，这样方便进行连接；</p></blockquote><p>type的类型2：非等值连接<br>非等值连接，意味着值之间的连接方式不是由等号确定的，也就是其他的关系。<br>例30：查询员工的姓名和工资的等级:        </p><pre><code>select name, level    from employeesjoin salary_grade    on employees.salary between salary_grade.lowest_sal and salary_grade.highest_sal;</code></pre><p>type的类型3：自连接<br>顾名思义，自连接就是自己和自己连接，也就是表格中的两个字段之间产生了关联，然后形成一个新的表格了。<br>例31：查询员工表employees中员工名和他的领导的名字:      </p><pre><code>select e.name, m.namefrom employees ejoin employees m    on e.manager_id = m.id;</code></pre><blockquote><p>备注：这个例子中，表格中的一些行，既是领导，也是员工，所以要自己与自己连接，注意上述例子中通过不同的别名实现了对同一个表格的区分；    </p></blockquote><p>type的类型4：左外连接<br>左外连接的意思是，将第一个表格作为关键表，第二个表格作为不关键表；左外连接与内连接的区别在于第一个表格的所有内容将会被保留，第二个表格的内容，如果与第一个表格有关系，则被保留，否则不保留。<br>例32：找出女生表格beauty中男朋友不出现在男生表格boy中的女生的姓名：    </p><pre><code>select b.name    from beauty b    left outer join boy bo    on b.bf_id = bo.id    where bo.id is null;</code></pre><blockquote><p>备注：这里使用where表示，from 后面的一串形式，就是一个表格；</p></blockquote><p>type的类型5：右外连接<br>右外连接的意思是，将第一个表格作为不关键表，第二个表格作为关键表；右外连接与内连接的区别在于第二个表格的所有内容将会被保留，第一个表格的内容，如果与第一个表格有关系，则被保留，否则不保留。<br>例33：找出女生表格beauty中男朋友不出现在男生表格boy中的女生的姓名：    </p><pre><code>select b.name    from boy bo   right outer join beauty b  on b.bf_id = bo.id    where bo.id is null;</code></pre><p>type的类型6：全外连接<br>全外连接的意思是，将所有的都显示出来，但是是按照一定的连接方式。与前述的连接方式的区别在于，两个表内连接的部分将会被保留，一个表有，另一个表没有的部分也将被保留。<br>例34：显示出男生表boy和女生表beauty的全部内容，并将互为男女朋友的放在一起：    </p><pre><code>select bo.*, b.*    from beauty b    full outer join boy bo    on bo.id = b.bf_id;</code></pre><p>type的类型7：交叉连接<br>交叉连接的意思是，将两个表格的内容互相连，每种可能的情况都遍历一遍<br>例35：显示出男生表boy和女生表beauty中的男女可能凑成的情侣的情况：    </p><pre><code>select bo.name, b.name    from beauty bcross join boy bo;</code></pre><blockquote><p>备注：以上几种连接方式的区别总结如下：<br>内连接表示两个表格之间的交集；<br>左外和右外连接表示使用一个表的全部和另一个表中有用的信息，相当于交集加上一个集合；<br>全外连接，表示两个表格的信息全部按照一定的规则使用，相当于全集；<br>交叉连接，表示两个表格所有可能出现的组合情况，也叫笛卡尔连接。    </p></blockquote><h2 id="Part8-子查询"><a href="#Part8-子查询" class="headerlink" title="Part8: 子查询"></a>Part8: 子查询</h2><p>子查询的意思是，将一个查询过程的结果作为另一个查询过程的条件。一般情况下，可以在from后的表格中加入子查询，where/having后的筛选条件中加入子查询.<br>备注：子查询的优先级高于主查询的；    </p><p>类型1：单行子查询<br>单行子查询的意思是，子查询的结果是一个值<br>例36：查询员工表employees中工资比sobel高的员工的姓名：    </p><pre><code>select namefrom employeeswhere salary&gt;(select salaryfrom employeeswhere name = &#39;sboel&#39;);</code></pre><p>备注：这里的查询结果就是一个值，也就是1个工资的结果；    </p><p>类型2：多行子查询<br>多行子查询的意思是，子查询的结果是很多值<br>例37：查询平均工资最低的部门编号：    </p><pre><code>select department_id, avg(salary)      from employees  group by department_id  having avg(salary) = (select min(avg(salary))from (select avg(salary)from employeesgroup by department_id)   );</code></pre><blockquote><p>备注：其中，表征每个部门的平均工资的表格就是输出的多行子查询；<br>另外，还准备了一个多行子查询的经典例题：<br>例38：查询各个部门中，工资比本部门平均工资高的员工的姓名：     </p><pre><code>select namefrom employees e   join (select avg(salary) ag, department_idfrom employeesgroup by department_id    ) fon e.department_id = f.department_idwhere e.salary &gt; f.ag    group by e.department_id;</code></pre><p>备注：如果多行子查询结果输出的话，需要将子查询的结果与目标相关联，才方便进行筛选；    </p></blockquote><h2 id="Part9-分页查询"><a href="#Part9-分页查询" class="headerlink" title="Part9: 分页查询"></a>Part9: 分页查询</h2><p>分页查询表示查询出的结果长度。语法如下：<br>select 字段名<br>from 表名1<br>[type] join 表名2<br>on 连接条件<br>where 筛选条件<br>group by 分组条件<br>having 筛选条件<br>order by 排序条件 排序方式<br>limit offset, size<br>执行顺序如下：       </p><ol><li>from 表名1</li><li>[type] join 表名2</li><li>on 连接条件</li><li>where 筛选条件</li><li>group by 分组条件</li><li>having 分组条件</li><li>select 字段名</li><li>order by 排序条件 排序方式</li><li>limit offset, size<blockquote><p>备注:其中offset表示分页开始的地方，size表示表格的长度，这里offset从0开始；</p></blockquote></li></ol><p>例39：查询员工表employees中工资最高的10个人的名字：    </p><pre><code>select name   from employees    order by salary desclimit 0, 10;</code></pre><h2 id="Part10-联合查询"><a href="#Part10-联合查询" class="headerlink" title="Part10: 联合查询"></a>Part10: 联合查询</h2><p>联合查询的意义在于，能够将多个查询语句分开写。<br>语法如下：<br>select 字段名1 from 表格1 where 筛选条件1<br>union<br>select 字段名2 from 表格2 where 筛选条件2；    </p><blockquote><p>备注：为了能够生成结果，需要保证筛选的字段名1和字段名2之间需要相互兼容；    </p></blockquote><p>例40：查询员工表employees中工资<3000和工资>10000的员工的姓名：    </p><pre><code>select namefrom employees where salary &gt; 10000 or salary &lt; 3000;</code></pre><pre><code>select name from employees where salary&lt;3000unionselect name from employees where salary&gt;10000;</code></pre><blockquote><p>备注：两者的输出结果不一致，因为查询的方式不一致；<br>备注：union本身自带去重效果，如果要保留重复，要使用union all；    </p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础1</title>
    <link href="/2020/02/09/MySQL%E5%9F%BA%E7%A1%801/"/>
    <url>/2020/02/09/MySQL%E5%9F%BA%E7%A1%801/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇：数据库的基本知识"><a href="#第一篇：数据库的基本知识" class="headerlink" title="第一篇：数据库的基本知识"></a>第一篇：数据库的基本知识</h1><h2 id="Part1-本部分内容的简单介绍"><a href="#Part1-本部分内容的简单介绍" class="headerlink" title="Part1: 本部分内容的简单介绍"></a>Part1: 本部分内容的简单介绍</h2><p>这是数据处理模块的第一个部分。数据处理模块将包含：MySQL基础，MySQL进阶，基于Python的爬虫以及数据处理部分。<br>MySQL部分将包含以下内容：<br><img src="/images/MySQL001.png" srcset="/img/loading.gif" alt="" title="MySQL WHOLE"></p><h2 id="Part2-数据库的好处"><a href="#Part2-数据库的好处" class="headerlink" title="Part2: 数据库的好处"></a>Part2: 数据库的好处</h2><ol><li>能够持久化地储存数据</li><li>能够进行系统性地管理</li></ol><h2 id="Part3-数据库的相关概念"><a href="#Part3-数据库的相关概念" class="headerlink" title="Part3: 数据库的相关概念"></a>Part3: 数据库的相关概念</h2><ol><li>Data Base(DB):数据库，数据存储的仓库，有规范的数据存储形式；  </li><li>Data Base Management System(DBMS):数据库处理系统，能够通过规范化的操作，对数据库实现增删改查等操作； </li><li>Structure Query Language(SQL):结构化查询语言，是DBMS实现功能的载体。</li><li>Data Query Language(DQL):数据查询语言，负责数据的查询；</li><li>Data Manipulation Language(DML):数据操纵语句，用于添加、删除、修改、查询数据库记录，并检查数据完整性；  </li><li>Data Definition Language(DDL):数据定义语句，用于库和表的创建、修改、删除；  </li><li>Data Control Language(DCL):数据控制语句，用于定义用户的访问权限和安全级别。  </li></ol><h2 id="Part4-MySQL语法规范"><a href="#Part4-MySQL语法规范" class="headerlink" title="Part4:MySQL语法规范"></a>Part4:MySQL语法规范</h2><ol><li>不区分大小写,但建议关键字大写，表名、列名小写</li><li>命名建议驼峰写法</li><li>每条命令最好用分号结尾</li><li>每条命令根据需要，可以进行缩进 或换行</li><li>注释<br>单行注释：#注释文字<br>单行注释：— 注释文字<br>多行注释：/<em> 注释文字  </em>/</li></ol><h2 id="Part5：MySQL的基本命令"><a href="#Part5：MySQL的基本命令" class="headerlink" title="Part5：MySQL的基本命令"></a>Part5：MySQL的基本命令</h2><ol><li>show databases; 这个操作是显示当前的系统中，有多少个数据库，返回的结果以数据库的首字母，按照a~z的顺序排列；</li><li>use 库名; 表示进入这个库了，之后这个库中表的操作等都可以展开；</li><li>show tables; 查看这个仓库中的所有表，返回的结果以表名的首字母，按照a~z的顺序排列；</li><li>show tables from 库名;查看这个仓库中的所有表，返回的结果以表名的首字母，按照a~z的顺序排列；</li><li>select database(); 查询当前所在的数据库；</li><li>desc 表名;查询这个表格的结构</li></ol><h3 id="小提醒"><a href="#小提醒" class="headerlink" title="小提醒"></a>小提醒</h3><blockquote><ol><li>每次打开数据库操作，都要看看数据库是否已经被开启；</li><li>使用一个数据库时，首先要进入这个库，使用use。</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown的使用说明</title>
    <link href="/2019/12/29/markdown%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2019/12/29/markdown%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<hr><p>title: Markdown的使用说明<br>date: 2019-12-29 17:26:18<br>tags: 编辑软件  常用软件</p><h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a>Markdown学习笔记</h1><h2 id="Part-0-思维导图"><a href="#Part-0-思维导图" class="headerlink" title="Part 0:思维导图"></a>Part 0:思维导图</h2><p><img src="/images/Markdown.png" srcset="/img/loading.gif" alt=""></p><h2 id="Part-1-文字处理"><a href="#Part-1-文字处理" class="headerlink" title="Part 1:文字处理"></a>Part 1:文字处理</h2><h3 id="A-加粗"><a href="#A-加粗" class="headerlink" title="A.加粗"></a>A.加粗</h3><p>操作:在文本的前后各增加两个<code>*</code>即可<br>例如： <strong>火箭</strong>  </p><h3 id="B-倾斜"><a href="#B-倾斜" class="headerlink" title="B.倾斜"></a>B.倾斜</h3><p>操作：在文本的前后各增加一个<code>*</code>即可<br>例如：<em>火箭</em>   </p><h3 id="C-颜色"><a href="#C-颜色" class="headerlink" title="C.颜色"></a>C.颜色</h3><p>操作：<code>&lt;font color=&quot;pink&quot;&gt;火箭&lt;/font&gt;</code><br>例如： <font color="pink">火箭</font>    </p><h3 id="D-字体"><a href="#D-字体" class="headerlink" title="D.字体"></a>D.字体</h3><p>操作：<code>&lt;font face=&quot;微软雅黑&quot;&gt;火箭&lt;/font&gt;</code><br>例如：<font face="微软雅黑">火箭</font>   </p><h3 id="E-划线"><a href="#E-划线" class="headerlink" title="E.划线"></a>E.划线</h3><p>中划线:<br>操作：<code>~~要删除的内容~~</code><br><del>要删除的内容</del>  </p><p>操作：<code>&lt;s&gt;要删除的内容&lt;/s&gt;</code><br><s>要删除的内容</s>       </p><p>下划线：<code>&lt;span style = &quot;border-bottom:2px dashed yellow;&quot;&gt;</code><br><span style = "border-bottom:2px dashed yellow;">要强调的内容</span> </p><h2 id="Part-2-段落处理"><a href="#Part-2-段落处理" class="headerlink" title="Part 2:段落处理"></a>Part 2:段落处理</h2><h3 id="F-序号"><a href="#F-序号" class="headerlink" title="F.序号"></a>F.序号</h3><p><code>一个&#39;#&#39;表示大号</code><br><code>两个&#39;#&#39;表示中号</code><br><code>三个&#39;#&#39;表示小号</code>  </p><blockquote><p>注意：必须在行首</p></blockquote><h3 id="G-换行"><a href="#G-换行" class="headerlink" title="G.换行"></a>G.换行</h3><p>操作：语句结尾两个空格<br>例如：markdown还算不错<br>空两格还行</p><h3 id="H-缩进"><a href="#H-缩进" class="headerlink" title="H.缩进"></a>H.缩进</h3><p>&emsp;<br><code>&amp;emsp;</code>表示缩进1个空格   </p><blockquote><p>注意：必须在行首</p></blockquote><h3 id="I：插入图片"><a href="#I：插入图片" class="headerlink" title="I：插入图片"></a>I：插入图片</h3><p>要说明的是，本地站点文件source下要创建images文件夹，集中存放图片<br>插入本地图片，格式如下：<br><code>![](/images/MJ.jpg &quot;Michael Jackson&quot;)</code><br>其中，”Michael Jackson”是鼠标放在图片上的提示符。<br><img src="/images/MJ.jpg" srcset="/img/loading.gif" alt="" title="Michael Jackson">   </p><blockquote><p>注意：插入的内容需要用相对路径，而非绝对路径。<br>即markdown所在的文件夹要和图片所在的文件夹一致。</p></blockquote><p>插入网络图片，格式如下：<br><code>![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D480/sign=42cc0ecf6659252da3171c0c049a032c/2fdda3cc7cd98d109adce0e4273fb80e7aec90df.jpg &quot;Michael Jackson&quot;)</code>    </p><p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D480/sign=42cc0ecf6659252da3171c0c049a032c/2fdda3cc7cd98d109adce0e4273fb80e7aec90df.jpg" srcset="/img/loading.gif" alt="" title="Michael Jackson"></p><h3 id="J-分割线"><a href="#J-分割线" class="headerlink" title="J:分割线"></a>J:分割线</h3><p>操作：四个<code>*</code>或者<code>-</code></p><hr><h2 id="Part3-引用链接"><a href="#Part3-引用链接" class="headerlink" title="Part3:引用链接"></a>Part3:引用链接</h2><h3 id="K-引用"><a href="#K-引用" class="headerlink" title="K.引用"></a>K.引用</h3><p>操作：直接加&gt;号<br>例如：  </p><blockquote><p>这是一个引用<br>注意：如果直接回车的话，下一行的内容也会变成引用。所以需要回车两次。</p></blockquote><h3 id="L-超链接"><a href="#L-超链接" class="headerlink" title="L.超链接"></a>L.超链接</h3><p>操作：<code>[链接文字](链接网址 &quot;标题&quot;)</code>  </p><p>例如:<a href="http://www.baidu.com" target="_blank" rel="noopener" title="百度">百度主页</a>    </p><h2 id="Part4-代码模块"><a href="#Part4-代码模块" class="headerlink" title="Part4:代码模块"></a>Part4:代码模块</h2><h3 id="M-代码"><a href="#M-代码" class="headerlink" title="M.代码"></a>M.代码</h3><p>代码前+3个英文状态下不加control的~+代码类型</p><pre><code>def add(x,y):    return x+y</code></pre><h2 id="Part5-数学公式"><a href="#Part5-数学公式" class="headerlink" title="Part5:数学公式"></a>Part5:数学公式</h2><h3 id="N-字符"><a href="#N-字符" class="headerlink" title="N.字符"></a>N.字符</h3><p>上标：<br>操作：<code>\hat{a}</code>，如： <script type="math/tex">\hat{a}</script>    </p><p>操作：<code>\bar{a}</code>，如： <script type="math/tex">\bar{a}</script>   </p><p>操作：<code>\tilde{a}</code>，如： <script type="math/tex">\tilde{a}</script>  </p><p>操作：<code>\vec{a}</code>，如: <script type="math/tex">\vec{a}</script></p><p>操作：<code>\dot{a}</code>，如：<script type="math/tex">\dot{a}</script> </p><p>操作：<code>\ddot{a}</code>，如：<script type="math/tex">\ddot{a}</script>  </p><p>肩膀：操作：<code>^</code>，如：<script type="math/tex">a^4</script>    </p><p>角标：操作:<code>_</code>，如：<script type="math/tex">a_4</script>   </p><h3 id="O-函数"><a href="#O-函数" class="headerlink" title="O.函数"></a>O.函数</h3><p>分数：操作：<code>\frac{a}{b}</code>，如：<script type="math/tex">\frac{a}{b}</script>   </p><p>绝对值：操作：<code>||</code>，如：<script type="math/tex">|x|</script></p><p>范数：操作：<code>\ell_p</code>，如：<script type="math/tex">\ell_p</script></p><p>排列：操作：<code>A_{a}^{b}</code>，如:<script type="math/tex">A_{a}^{b}</script>   </p><p>组合：操作：<code>C_{a}^{b}</code>，如：<script type="math/tex">C_{a}^{b}</script>   </p><p>组合：操作：<code>{a\choose b}</code>， 如：<script type="math/tex">{a\choose b}</script></p><p>阶乘：操作：<code>!</code> ， 如：<script type="math/tex">a!</script></p><p>对数：操作：<code>\lna</code>，如：<script type="math/tex">\ln x</script></p><p>对数：操作：<code>\log_a b</code>，如：<script type="math/tex">\log_a b</script></p><p>对数：操作：<code>\lg a</code>，如：<script type="math/tex">\lg a</script> </p><p>正弦：操作：<code>sin a</code>，如：<script type="math/tex">sin a</script> </p><p>余弦：操作：<code>cos a</code>，如：<script type="math/tex">cos a</script> </p><p>正切：操作：<code>tan a</code>，如：<script type="math/tex">tan a</script> </p><p>累加：操作：<code>\sum_{a}^{b}</code>，如：<script type="math/tex">\sum_{a}^{b}</script>    </p><p>累积：操作：<code>\prod_{a}^{b}</code>，如：<script type="math/tex">\prod_{a}^{b}</script> </p><h3 id="P-运算"><a href="#P-运算" class="headerlink" title="P.运算"></a>P.运算</h3><p>加减：操作：<code>\pm</code>，如： <script type="math/tex">a \pm b</script> </p><p>乘法：操作：<code>\times</code>，如： <script type="math/tex">a \times b</script> </p><p>点乘：操作：<code>\cdot</code>，如：<script type="math/tex">a \cdot b</script></p><p>除法：操作：<code>\div</code>，如：<script type="math/tex">a \div b</script>  </p><p>开方：操作：<code>\sqrt{a}</code>，如：<script type="math/tex">\sqrt{a}</script></p><p>开方：操作：<code>\sqrt[n]{a}</code>，如：<script type="math/tex">\sqrt[n]{a}</script></p><p>积分：操作：<code>\int_a^b</code>，如：<script type="math/tex">\int_a^b</script>  </p><p>积分：操作: <code>\iint_a^b$</code>，如：<script type="math/tex">\iint_a^b</script> </p><p>极限：操作：<code>\lim_a b</code>，如：<script type="math/tex">\lim_a b</script>  </p><p>微分：操作：<code>\frac{da}{db}</code>，如：<script type="math/tex">\frac{da}{db}</script> </p><p>微分：操作：<code>\frac{d^2a}{db^2}</code>，如：<script type="math/tex">\frac{d^2a}{db^2}</script> </p><p>偏微分：操作：<code>\frac{\partial^2 a}{\partial b^2}</code>，如：<script type="math/tex">\frac{\partial^2 a}{\partial b^2}</script> </p><h3 id="Q-符号"><a href="#Q-符号" class="headerlink" title="Q.符号"></a>Q.符号</h3><p>不等于：操作：<code>\neq</code>，如：<script type="math/tex">a \neq b</script> </p><p>恒等于：操作：<code>\equiv</code>，如：<script type="math/tex">a \equiv b</script> </p><p>大于等于：操作：<code>\geq</code>，如：<script type="math/tex">a \geq b</script> </p><p>小于等于：操作：<code>\leq</code>，如：<script type="math/tex">a \leq b</script> </p><p>约等于：操作：<code>\approx</code>，如：<script type="math/tex">a \approx b</script> </p><h3 id="R-集合"><a href="#R-集合" class="headerlink" title="R.集合"></a>R.集合</h3><p>空集：操作：<code>\emptyset</code>，如：<script type="math/tex">\emptyset</script> </p><p>属于：操作：<code>\in</code>，如：<script type="math/tex">a \in b</script> </p><p>不属于：操作：<code>\notin</code>，如：<script type="math/tex">a \notin b</script>   </p><p>包含于：操作：<code>\subset</code>，如：<script type="math/tex">a \subset b</script>   </p><p>包含：操作：<code>\supset</code>，如：<script type="math/tex">a \supset b</script>   </p><p>真包含于：操作：<code>\subseteq</code>，如：<script type="math/tex">a \subseteq b</script>  </p><p>真包含：操作：<code>\supseteq</code> ，如：<script type="math/tex">a \supseteq b</script></p><p>交集：操作：<code>\bigcap</code>  ，如：<script type="math/tex">a \bigcap b</script> </p><p>并集：操作：<code>\bigcup</code>，如：<script type="math/tex">a \bigcup b</script>    </p><h3 id="S-逻辑关系"><a href="#S-逻辑关系" class="headerlink" title="S.逻辑关系"></a>S.逻辑关系</h3><p>与：操作：<code>\emptyset</code>，如：<script type="math/tex">a \bigwedge b</script> </p><p>或：操作：<code>\bigvee</code>，如：<script type="math/tex">a \bigvee b</script> </p><p>存在：操作：<code>\exists</code>，如：<script type="math/tex">\exists a</script> </p><p>所有：操作：<code>\forall</code>，如：<script type="math/tex">\forall a</script> </p><p>因为：操作：<code>\because</code>，如：<script type="math/tex">\because</script> </p><p>所以：操作：<code>\therefore</code>，如：<script type="math/tex">\therefore</script> </p><h3 id="T-常用字母"><a href="#T-常用字母" class="headerlink" title="T.常用字母"></a>T.常用字母</h3><p><code>\alpha</code>：<script type="math/tex">\alpha</script> 　<br>　<br><code>\beta</code>：<script type="math/tex">\beta</script><br>　　<br><code>\gamma</code>：<script type="math/tex">\gamma</script> 　　</p><p><code>\delta</code>：<script type="math/tex">\delta</script> 　</p><p><code>\Delta</code>：<script type="math/tex">\Delta</script> 　</p><p><code>\epsilon</code>：<script type="math/tex">\epsilon</script> 　</p><p><code>\varepsilon</code>：<script type="math/tex">\varepsilon</script><br>　<br><code>\zeta</code>：<script type="math/tex">\zeta</script> 　　</p><p><code>\eta</code>：<script type="math/tex">\eta</script> 　</p><p><code>\theta</code>：<script type="math/tex">\theta</script> 　</p><p><code>\Theta</code>：<script type="math/tex">\Theta</script> 　<br>　<br><code>\kappa</code>：<script type="math/tex">\kappa</script><br>　<br><code>\lambda</code>：<script type="math/tex">\lambda</script> 　</p><p><code>\Lambda</code>：<script type="math/tex">\Lambda</script> 　</p><p><code>\mu</code>：<script type="math/tex">\mu</script> </p><p><code>\pi</code>：<script type="math/tex">\pi</script> </p><p><code>\varpi</code>：<script type="math/tex">\varpi</script> </p><p><code>\rho</code>：<script type="math/tex">\rho</script> 　<br>　<br><code>\sigma</code>：<script type="math/tex">\sigma</script> </p><p><code>\Sigma</code>：<script type="math/tex">\Sigma</script> </p><p><code>\tau</code>：<script type="math/tex">\tau</script> </p><p><code>\phi</code>：<script type="math/tex">\phi</script> </p><p><code>\varphi</code>：<script type="math/tex">\varphi</script> </p><p><code>\psi</code>：<script type="math/tex">\psi</script> </p><p><code>\omega</code>：<script type="math/tex">\omega</script> </p><p><code>\Omega</code>：<script type="math/tex">\Omega</script> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/29/hello-world/"/>
    <url>/2019/12/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="lang-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><pre><code class="lang-python">def add(x,y):    return x+y</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
